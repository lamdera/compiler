
### Compiler extension: Wire/Evergreen

Wire is a compiler extension that automatically generates encoders and decoders for data types using Evergreen (see relevant [talk by Mario](https://www.youtube.com/watch?v=4T6nZffnfzg)).

Currently we're only targeting JSON, as there is a good core library that handles the details for us, but in future we'll likely have more formats i.e. binary, and perhaps others specific to certain performance or memory characteristics we want for different use cases.

Here's the original example of the "target" generated code for encoders/decoders of a `Union` custom type and a `AllTypes` record:

```elm
evg_e_Union : Union -> E.Value
evg_e_Union evg_p0 =
    case evg_p0 of
        Recursive evg_v0 ->
            E.list identity [ E.string "Recursive", evg_e_Union evg_v0 ]
        Valued evg_v0 ->
            E.list identity [ E.string "Valued", E.int evg_v0 ]
        DeeplyValued evg_v0 ->
            E.list identity [ E.string "DeeplyValued", E.list E.bool evg_v0 ]
        Leaf ->
            E.list identity [ E.string "Leaf" ]


evg_d_Union : D.Decoder Union
evg_d_Union =
    D.oneOf
        [ EG.union1 "Recursive" (D.lazy (\_ -> evg_d_Union)) Recursive
        , EG.union1 "Valued" D.int Valued
        , EG.union1 "DeeplyValued" (D.list D.bool) DeeplyValued
        , EG.union "Leaf" Leaf
        ]


evg_e_AllTypes : AllTypes -> E.Value
evg_e_AllTypes evg_p0 =
    E.list identity
        [ E.int evg_p0.int
        , E.float evg_p0.float
        , E.bool evg_p0.bool
        , EG.e_char evg_p0.char
        , E.string evg_p0.string
        , E.list E.int evg_p0.listInt
        , E.set E.float evg_p0.setFloat
        , E.array E.string evg_p0.arrayString
        , EG.e_dict E.string (E.list E.int) evg_p0.dict
        , EG.e_time evg_p0.time
        , EG.e_order evg_p0.order
        , evg_e_Union evg_p0.union
        , E.null
        ]


evg_d_AllTypes : D.Decoder AllTypes
evg_d_AllTypes =
    D.succeed AllTypes
        |> EG.atIndex 0 D.int
        |> EG.atIndex 1 D.float
        |> EG.atIndex 2 D.bool
        |> EG.atIndex 3 EG.d_char
        |> EG.atIndex 4 D.string
        |> EG.atIndex 5 (D.list D.int)
        |> EG.atIndex 6 (EG.d_set D.float)
        |> EG.atIndex 7 (D.array D.string)
        |> EG.atIndex 8 (EG.d_dict D.string (D.list D.int))
        |> EG.atIndex 9 EG.d_time
        |> EG.atIndex 10 EG.d_order
        |> EG.atIndex 11 evg_d_Union
        |> EG.atIndex 12 EG.d_unit
```

It's pretty straightforward:

- Custom types are encoded as a list containing the custom type tag name as first element and all parameters as subsequent elements
- Records are encoded as a list containing all the encoded field values in order with no labels

That's it!

The above code is now what gets silently generated by Wire/Evergreen in the background. So for a given type `AllTypes`, the functions `evg_e_AllTypes` and `evg_d_AllTypes` will be automatically generated and available during compilation.

Given we control both encoder/decoder, we can rely on the knowledge of how we encoded things to decode them, thus removing the need for keeping redundant intermediary labels. In the future we could potentially optimise this even further with more tricks, like enumerating the custom type tag names to get an even smaller representation, or skipping JSON entirely.

#### How to develop wire

The current process is a little rickety, but is documented in `extra/WireTest.hs` â€“ do read it as it'll probably save you a lot of time on the feedback loop!
